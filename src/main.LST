C51 COMPILER V7.06   MAIN                                                                  07/25/2013 23:19:40 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\software\keil\C51\BIN\C51.EXE main.c COMPACT BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          
   2          #include "config.h"
   3          #include "key.h"
   4          #include "adc.h"
   5          #include "pwm.h"
   6          #include "eeprom.h"
   7          #include "mylcr.h"
   8          
   9          
  10          
  11          extern Trg;
  12          extern Cont;
  13          extern cnt_plus;
  14          
  15          unsigned char  Status=STOP;          //系统状态
  16          
  17          xdata unsigned char Fun_idx=FUN_R;   //当前功能索引
  18          xdata unsigned char Rang_idx=R40;    //当前量程索引
  19          xdata unsigned char Frq_idx=F1K;     //当前频率索引
  20          xdata unsigned char Mode_idx=MODE_S; //当前模式索引
  21          
  22          xdata unsigned char Gain_idx=GAIN1;  //当前增益索引
  23          xdata unsigned char Vxy_idx=VX_A;    //当前测量索引
  24          
  25          
  26          //测量结果
  27          xdata int Vxy[6]={0,0,0,0,1,1}; //Vxy[Vx_a,Vy_b,Vx_c,Vy_d,g_up,g_down]
  28          //修正参数
  29          xdata struct Ida{
  30           char zo[3];//三个频率下的零点改正值
  31           char j1;   //相位补偿(3倍档)
  32           char j2;   //相位补偿(10倍档)
  33           char J[4];  //相位补偿(V/I变换器)
  34           char R[4]; //下臂电阻修正(40,1k,10k,100k)
  35           char g1;   //增益修正(3倍档)
  36           char g2;   //增益修正(10倍档)
  37           char phx; //1kHz以下相位改正
  38           char R4b; //100k档7.8kHz频率下的幅度补偿
  39           char G2b; //9倍档7.8kHz频率下的幅度补偿
  40           char feq; //频率修正
  41           char ak;  //AD斜率修正
  42           float QRs[3],QXs[3]; //短路清零数据
  43           float QRo[3],QXo[3]; //开路清零数据
  44          } cs;
  45          
  46          
  47          /***********************************************************************
  48          Function : WDTC
  49          Note     : 清除看门狗
  50          ***********************************************************************/
  51          void WDTC() { WDT_CONTR =0x3C; }
  52          
  53          /***********************************************************************
  54          Function : INTT0 interrupt
  55          Note     : 定时器中断处理函数
C51 COMPILER V7.06   MAIN                                                                  07/25/2013 23:19:40 PAGE 2   

  56          ***********************************************************************/
  57          void INTT0(void) interrupt 1 using 1
  58          {
  59   1              TH0 = 0xF5, TL0 = 0x95;    //1ms定时重装
  60   1              //UpdateTimers();
  61   1      }
  62          
  63          /***********************************************************************
  64          Function : timerInter1
  65          Note     : T1中断，LCR数据采集
  66          ***********************************************************************/
  67          void timerInter1(void) interrupt 3 
  68          {
  69   1              int c=0;
  70   1              TH1 = 0x96, TL1 = 0xAB;      //20ms定时重装
  71   1       
  72   1              if (Status == METER)
  73   1              {
  74   2                Vxy[Vxy_idx] = ADC_Read();   //读取电压值
  75   2      
  76   2                if ((Vxy_idx==VX_A)||(Vxy_idx==VX_C))
  77   2                {//电压模值才能反应运放的输出幅度，所以增益切换判断得用模值
  78   3                  if (Vxy_idx==VX_A) c = absMax(Vxy[VX_C],Vxy[VY_D]); //切换到下臂
  79   3                  if (Vxy_idx==VX_C) c = absMax(Vxy[VX_A],Vxy[VY_B]); //切换到上臂
  80   3      
  81   3                  if (c>VFULL) { setGain(Gain_idx--);}  //减小增益
  82   3                  else if (c<GAD*1) {setGain(GAIN27);}  //增加27倍
  83   3                  else if (c<GAD*3) {setGain(GAIN9);}   //增加9倍
  84   3                  else if (c<GAD*9) {setGain(GAIN3);}   //增加3倍
  85   3      
  86   3                  if (Vxy_idx==VX_A) Vxy[GAIN_DOWN] = Gain_idx;  //记录下臂增益
  87   3                  if (Vxy_idx==VX_C) Vxy[GAIN_UP] = Gain_idx;    //记录上臂增益
  88   3                 }
  89   2       
  90   2                if (Vxy_idx == VY_D) Status = DISPLAY;
  91   2      
  92   2                Vxy_idx = (Vxy_idx + 1)%4;
  93   2      
  94   2                if (Vxy_idx==VX_A) K3=1;  //切换到上臂
  95   2                if (Vxy_idx==VX_C) K3=0;  //切换到下臂
  96   2              }
  97   1      
  98   1              KeyRead();
  99   1          
 100   1          if (Trg&KEY_F) {setFrq(Frq_idx);}  //设置频率
 101   1      }
 102          
 103          /***********************************************************************
 104          Function : Time_Init
 105          Note     : 定时器初始化 
 106          ***********************************************************************/
 107          void Time_Init(void)
 108          {     
 109   1           TCON=0, TMOD=0x11; //将T0和T1置为16重装位定时器
 110   1           TH1 = 0x96, TL1 = 0xAB;    //20ms定时
 111   1           TR1=1;  //T1开始计数
 112   1           TH0 = 0xF5, TL0 = 0x95;    //1ms定时
 113   1           TR0=0;  //T0暂停计数
 114   1              
 115   1           ET1=1;  //T1开中断
 116   1           ET0=1;  //T0开中断
 117   1      }
C51 COMPILER V7.06   MAIN                                                                  07/25/2013 23:19:40 PAGE 3   

 118          
 119          /***********************************************************************
 120          Function : Main
 121          Note     : 主程序
 122          ***********************************************************************/
 123          void main()
 124          {
 125   1          Time_Init();    //定时器初始化
 126   1      
 127   1          EA=1;           //开总中断
 128   1      
 129   1          ADC_Init(0);    //设置AD转换通道为P1.0
 130   1      
 131   1          P1M0 = 0xFC;    //P1.234567置为推换口
 132   1          P1M1 = 0x03;    //P1.01置为高阻抗
 133   1          P2M0 = 0xFF;    //P2.01234567置为推勉输出
 134   1          P2 = 0x0F; 
 135   1      
 136   1          PWM_Init();     //DDS初始化 把PCA置为PWM
 137   1              
 138   1          set90(2);       //初始设置相位
 139   1          setRng(Rang_idx);  //初始设置量程
 140   1          setGain(Gain_idx); //初始设置增益
 141   1          setFrq(Frq_idx);   //DDS初始设置为1kHz      
 142   1      
 143   1          //LCD_INIT();
 144   1      
 145   1          //LCD_PrintString("LCR 3.0");
 146   1          //LCD_2ndRow();
 147   1          //LCD_PrintString("XJW Putian, 2012");
 148   1      
 149   1          while(1)
 150   1           {
 151   2                 WDTC(); 
 152   2      
 153   2                 //键盘处理 
 154   2                 if (Trg&KEY_M) {M_Done(Fun_idx);}  //功能切换
 155   2                 if (Trg&KEY_X) {X_Done(Mode_idx);} //模式切换
 156   2                 if (Trg&KEY_R) {setRng(0);}        //量程步进
 157   2                 if (Trg&KEY_C) {C_Done(0);}        //清零
 158   2                 if (Cont&KEY_M)
 159   2                 {
 160   3                      cnt_plus++;
 161   3                      if (cnt_plus>100)  {cnt_plus=0;M_Done(FUN_S);}
 162   3                  } 
 163   2                 if (Cont&KEY_R)
 164   2                 {
 165   3                      cnt_plus++;
 166   3                      if (cnt_plus>100) {cnt_plus=0;setRng(1);} 
 167   3                  }
 168   2                 if (Cont&KEY_C)
 169   2                 {
 170   3                      cnt_plus++;
 171   3                      if (cnt_plus>100) {cnt_plus=0;C_Done(1);}
 172   3                  }
 173   2                 if (!(Cont)){cnt_plus=0;}
 174   2      
 175   2                 //显示处理
 176   2                 if (Status == DISPLAY ) 
 177   2                  {
 178   3                      Status = METER;
 179   3      
C51 COMPILER V7.06   MAIN                                                                  07/25/2013 23:19:40 PAGE 4   

 180   3                         //calcLCR();
 181   3                         //SendSem(meter_fine);
 182   3                         //showR();
 183   3                    } 
 184   2           }
 185   1      }
 186          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    628    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     86    ----
   PDATA SIZE       =      1       2
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
