{
int a[2]={129,17},f;
f=a[1]>;a[0];
printf("%d\n",a[f]);
} 

不提升如下：
int max(int x,int y)
{

int buf[2]={x,y};

unsigned int z;

int c;  

        z=x-y;

        c=x-y;

        z>;>;=31;

        z= ((x-c-y)&&1)^z;
    

return buf[z];

} 
一、寻找最大数的根据：

1、允许用逻辑表达式：
利用逻辑表达式的值， {a>;=b、a<b} = {0，1}。
2、不允许用逻辑表达式：
利用比特位

a^b 的最高位 ---- 判断符号是否相等
a-b 的最高位 ---- 在符号相同的情况下判断大小
a   的最高位 ---- a的符号
b   的最高位 ---- b的符号
int max(int a, int b)
{
int pair[2] = {a, b};
return pair[a < b];
}


这段代码的简单说明：

#define MASK 0x7fffffff

int max (int x, int y)

{

  int z;



  z =  (x>;>;31) - (y>;>;31) + (((x&MASK) - (y&MASK))>;>;31);

  z= (z+1)*(z+2)*(3-2*z)/6;

  return z*x + (1-z)*y;

 

}



思路：计算 x-y 的差，自己处理进位：

第一行：

(((x&MASK) - (y&MASK))>;>;31) 计算低 31 位相减后的符号，0 或 －1。也可以看成低 31 位相减后对高位的  借位。

(x>;>;31) - (y>;>;31) 是第 32 位的差，带符号扩展

z =  (x>;>;31) - (y>;>;31) + (((x&MASK) - (y&MASK))>;>;31);

处理进位.


第二行：

可以分析出，z 有四种可能的值，1， 0， -1, -2。其中 

1， 0 对应 x>;=y， －1， －2 对应 x < y

我对 z 作一个修正，即一个映射，把 1, 0 对应为 1; －1， －2 对应为 0。映射可用 Lagrange 插值公式得到。


第三行：
还是 Lagrange 插值， 1 ->; x, 0 ->; y



ps>; 第二行也可以直接从最高位判断正负。


----
那这样呢？

#define SHIFT (sizeof(int) * 8 - 1)



int max(int x, int y)

{

        unsigned int m, n;

        int ary[2] = {x, y};



        m = x ^ y;

        m = m & ~(m / 2) & ~(m / 4);

        n = m | 0x01;



        return ary[ ((x & n) + n / 2) / n ^ !((m >;>; SHIFT) & 0x01)];

}
说明一下吧：
这个算法是企图对x、y按位比较，简单地说，如果不考虑+、-号，则在第一次出现两者的位不相同时，该位是1的值比较大，如
00001111111100001111000011110000
00001110111100111111110011111010
左数第8位上，前者是1，后者是0，所以前者比后者大。
对于有符号的情况我们在后面再分析。
1、首先，x^y把x、y中不相同的位置1了，假设x^y=0...01X...X，后面的X表示任意的0或1，这表示在1所在的位置之前的位x、y是相等的，在这一位上或者x为1、y为0；或者x为0、y为1；我们主要是要确定哪一个为1。可惜的是我们无法得到0...010...0这个数以及1所在的位号(不然就要用循环去确定，这不符合题目的要求)
2、设m=x^y，则当x >; y时，x在该位上为1，所以x  & m = 0...01X...X，所以(x & m) / m 大约为1(注意“大约”，因为有等于0的可能存在，我们等会儿把它排除掉)；当x < y时，x & m = 0...00X...X，所以(x & m) / m = 0，现在我们的程序好象可以工作了。。。
3、但是，有一个BUG，如果m == 0呢？(x & m) / m会溢出!m = 0说明x=y，现在的处理是m = m | 0x01，即把最后一位置1，使m >;= 1!
这样当m == 0时，我们不管(x & m) / m算出来的是个啥结果，反正哪个都一样(x == y嘛!)，而m >; 0时，最后一位是不是1不影响我们的计算结果了!
4、前面说过这里还有个BUG，即当x在该位上为1时，我们不能确定(x & m) / m 一定 = 1，因为尽管x & m在该位上也为1，但x & m还是有可能 < m的(还是感叹如果我们能得到0..010...0这个数就好了!)。现在的处理是m = m & ~( m / 2 ) & ~( m / 4)，把m这个数变成0...0100X...X，算式也修正为((x & m) + m / 2) / m，这个可以满足我们的要求了
5、最后再来考虑一下有符号的情况
设t=((x & m) + m / 2) / m，f = m的第一位=m >;>; SHIFT(上面的&0x01其实可以不要)
则当m = 0时，表示x、y同号，这时按上面的方式确定最大值
当m = 1时，x、y一正一负，t表示x首位，为1则x < 0，为0则x >;= 0
总的说来：
(1)当f=0，t=0时最大值为y -----1
(2)当f=0，t=1时最大值为x -----0
(3)当f=1，t=0时最大值为x -----0
(4)当f=1，t=1时最大值为y -----1
显然结果是t ^ !f
(如果不让用!那就是t ^ (~f & 0x01))
m = m & ~( m / 2 ) & ~( m / 4)
为什么这句可以得到最高的那一位呢

不是最高的一位，而是把m变成：0...0100X...X这样的形式，即1后面有两个0
于是当x在该位上为1时:
(x & m) + m / 2 >;=0...0100...0 + 0...0010...0 = 0...0110...0 >;=m
(x & m) + m / 2) <= 0...01001...1 + 0...001001...1 <= 0...011...10 < 2m
所以((x & m) + m / 2) / m = 1
而当x在该位上为0时：
(x & m) + m / 2 <= 0...00001...1 + 0....001001...1 = 0...0011...1 < m
所以((x & m) + m / 2) / m = 0


